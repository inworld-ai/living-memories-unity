/*************************************************************************************************
 * Copyright 2022-2025 Theai, Inc. dba Inworld AI
 *
 * Use of this source code is governed by the Inworld.ai Software Development Kit License Agreement
 * that can be found in the LICENSE.md file or at https://www.inworld.ai/sdk-license
 *************************************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using Newtonsoft.Json;
using UnityEngine;
using Newtonsoft.Json.Linq;
using UnityEditor;

namespace Inworld.Framework.Graph
{
    /// <summary>
    /// ScriptableObject that represents a complete graph workflow within the Inworld framework.
    /// This asset can be created through Unity's Create menu and used to define conversational AI flows.
    /// Used for configuring nodes, edges, and execution logic for AI conversation systems and workflows.
    /// </summary>
    [CreateAssetMenu(fileName = "New Graph", menuName = "Inworld/Create Graph/Default", order = -3000)]
    public class InworldGraphAsset : ScriptableObject
    {
        /// <summary>
        /// The name identifier for the player in this graph.
        /// Used to reference the player entity within the conversation flow.
        /// </summary>
        [Header("Graph Configuration:")]
        [SerializeField] protected string m_PlayerName = "Player";
        
        /// <summary>
        /// The name identifier for this graph.
        /// Used to identify and reference this specific graph workflow.
        /// </summary>
        [SerializeField] protected string m_GraphName = "New Graph";
        
        /// <summary>
        /// If it has json file, use json way to compile.
        /// Otherwise, use traditional way.
        ///
        /// Json should always be generated by GraphEditor.
        /// </summary>
        [SerializeField] protected TextAsset m_GraphJson;
        
        [SerializeField] protected InworldUserData m_UserData;
        
        /// <summary>
        /// Components used by this graph. These mirror the 'components' array in unity_character_engine.json
        /// and will be serialized during SaveJson.
        /// </summary>
        [SerializeField] protected List<InworldComponentAsset> m_Components = new List<InworldComponentAsset>();
        
        /// <summary>
        /// The collection of nodes that make up this graph workflow.
        /// Contains all processing nodes that define the conversation logic and behavior.
        /// </summary>
        [SerializeField] protected List<InworldNodeAsset> m_Nodes = new List<InworldNodeAsset>();
        
        /// <summary>
        /// The starting node for graph execution.
        /// Defines the entry point where conversation flow begins.
        /// </summary>
        [SerializeField] protected InworldNodeAsset m_StartNode;
        
        /// <summary>
        /// The primary ending node for graph execution.
        /// Defines the main exit point where conversation flow concludes.
        /// </summary>
        [SerializeField] protected InworldNodeAsset m_EndNode;

        /// <summary>
        /// Alternative ending nodes for graph execution.
        /// Provides multiple possible exit points for different conversation outcomes.
        /// </summary>
        [SerializeField] protected List<InworldNodeAsset> m_EndNodes = new List<InworldNodeAsset>();
        
        /// <summary>
        /// The collection of edges that connect nodes in this graph.
        /// Defines the flow connections and transitions between conversation nodes.
        /// </summary>
        [SerializeField] protected List<InworldEdgeAsset> m_Edges = new List<InworldEdgeAsset>();
        
        // Runtime objects
        /// <summary>
        /// The runtime graph instance created from this asset.
        /// Contains the compiled graph structure used during execution.
        /// </summary>
        [Header("Runtime Data:")]
        protected InworldGraph m_RuntimeGraph;
        
        /// <summary>
        /// The compiled graph interface for optimized execution.
        /// Provides the compiled version of the graph for efficient runtime processing.
        /// </summary>
        protected CompiledGraphInterface m_CompiledGraph;
        
        /// <summary>
        /// The executor interface for running the graph.
        /// Manages the execution state and flow control of the conversation graph.
        /// </summary>
        protected ExecutorInterface m_Executor;

        // Json caches parsed from m_GraphJson for quick lookup
        protected JObject m_ParsedRoot;
        
        protected Dictionary<string, bool> m_JsonNodeRegistry;
        protected Dictionary<(string, string), bool> m_JsonEdgeRegistry;

        public virtual bool NeedSaveAsJson => false;
        public virtual bool NeedClearHistory => false;
        
        // YAN: A place for users to store their own data that's executing graph in the middle.
        public string TempData { get; set; }

        public bool RegisterJsonNode(string nodeName)
        {
            if (m_JsonNodeRegistry == null || !m_JsonNodeRegistry.ContainsKey(nodeName))
                return false;
            m_JsonNodeRegistry[nodeName] = true;
            return true;
        }

        public bool RegisterJsonEdge(string startNodeName, string endNodeName)
        {
            if (m_JsonEdgeRegistry == null || !m_JsonEdgeRegistry.ContainsKey((startNodeName, endNodeName)))
                return false;
            m_JsonEdgeRegistry[(startNodeName, endNodeName)] = true;
            return true;
        }
        // Public properties for runtime access
        /// <summary>
        /// Gets the runtime graph instance.
        /// Provides access to the active graph structure during execution.
        /// </summary>
        public InworldGraph Runtime => m_RuntimeGraph;
        
        /// <summary>
        /// Gets the executor interface for this graph.
        /// Provides access to the execution controller for managing graph flow.
        /// </summary>
        public ExecutorInterface Executor => m_Executor;
        
        /// <summary>
        /// Gets the collection of components in this graph.
        /// Provides access to all processing nodes that define the conversation logic.
        /// </summary>
        public List<InworldComponentAsset> Components => m_Components;
        
        /// <summary>
        /// Gets the collection of nodes in this graph.
        /// Provides access to all processing nodes that define the conversation logic.
        /// </summary>
        public List<InworldNodeAsset> Nodes => m_Nodes;
        
        /// <summary>
        /// Gets the collection of edges in this graph.
        /// Provides access to all connections between nodes in the conversation flow.
        /// </summary>
        public List<InworldEdgeAsset> Edges => m_Edges;
        
        /// <summary>
        /// Gets the starting node for this graph.
        /// Provides access to the entry point node for conversation flow.
        /// </summary>
        public InworldNodeAsset StartNode
        {
            get => m_StartNode;
            set => m_StartNode = value;
        }

        /// <summary>
        /// Gets the primary ending node for this graph.
        /// Provides access to the main exit point node for conversation flow.
        /// </summary>
        public InworldNodeAsset EndNode => m_EndNode;
        
        /// <summary>
        /// Gets the collection of alternative ending nodes for this graph.
        /// Provides access to multiple possible exit points for different conversation outcomes.
        /// </summary>
        public List<InworldNodeAsset> EndNodes => m_EndNodes;
        
        /// <summary>
        /// Gets the player name for this graph.
        /// Provides access to the player identifier used in conversation flow.
        /// </summary>
        public string PlayerName => m_PlayerName;
        
        /// <summary>
        /// Gets the name of this graph.
        /// Provides access to the graph identifier for reference and debugging.
        /// </summary>
        public string Name => m_GraphName;
        
        /// <summary>
        /// Clears all runtime objects and disposes of resources used by the graph execution.
        /// Stops the executor, disposes of compiled graph, and cleans up node and edge runtime data.
        /// </summary>
        public void ClearGraphRuntime()
        {
            if (m_Executor != null)
            {
                m_Executor.Stop();
                m_Executor.Dispose();
                m_Executor = null;
            }
            if (m_CompiledGraph != null)
            {
                m_CompiledGraph.Dispose();
                m_CompiledGraph = null;
            }
            foreach (InworldNodeAsset node in m_Nodes)
            {
                node.Runtime?.Dispose();
                node.Runtime = null;
            }
            foreach (InworldEdgeAsset edge in m_Edges)
            {
                edge.Runtime?.Dispose();
                edge.Wrapper?.Dispose();
            }
            if (m_RuntimeGraph != null)
            {
                m_RuntimeGraph.Dispose();
                m_RuntimeGraph = null;
            }
        }

        public virtual void ClearHistory()
        {
        }

        public bool IsJsonRegistered(InworldNodeAsset node) => m_JsonNodeRegistry != null &&
                                                               m_JsonNodeRegistry.ContainsKey(node.NodeName) &&
                                                               m_JsonNodeRegistry[node.NodeName];
        
        public void ParseJson()
        {
            if (m_ParsedRoot != null || string.IsNullOrEmpty(m_GraphJson?.text))
                return;
            m_ParsedRoot = JObject.Parse(m_GraphJson.text);
            if (!(m_ParsedRoot["main"] is JObject main))
                return;
            m_JsonNodeRegistry ??= new Dictionary<string, bool>();
            if (main["nodes"] is JArray nodes)
            {
                foreach (JToken n in nodes)
                {
                    string id = (string)n["id"];
                    if (!string.IsNullOrEmpty(id))
                        m_JsonNodeRegistry[id] = false;
                }
            }
            m_JsonEdgeRegistry ??= new Dictionary<(string, string), bool>();
            if (main["edges"] is JArray edges)
            {
                foreach (JToken e in edges)
                {
                    string fromNode = (string)e["from_node"];
                    string toNode = (string)e["to_node"];
                    if (!string.IsNullOrEmpty(fromNode) && !string.IsNullOrEmpty(toNode))
                        m_JsonEdgeRegistry[(fromNode, toNode)] = false;
                }
            }
        }

        public bool IsEdgeRegistered(InworldEdgeAsset edge) => m_JsonEdgeRegistry != null &&
                                                               m_JsonEdgeRegistry.ContainsKey((edge.StartNodeName, edge.EndNodeName)) &&
                                                               m_JsonEdgeRegistry[(edge.StartNodeName, edge.EndNodeName)];
        
        /// <summary>
        /// Clears all editor-time graph data and resets the graph to an empty state.
        /// Removes all node connections, clears start/end nodes, and empties the node and edge collections.
        /// </summary>
        public void ClearGraphEditorTime()
        {
            foreach (InworldNodeAsset node in m_Nodes)
            {
                if (!node) 
                    continue;
                node.Parents.Clear();
                node.Children.Clear();
                node.Edges.Clear();
            }
            m_StartNode = null;
            m_EndNode = null;
            m_EndNodes.Clear();
            m_Nodes.Clear();
            m_Edges.Clear();
        }

        /// <summary>
        /// Creates the runtime representation of this graph for execution.
        /// Initializes runtime graph, creates node and edge runtime objects, and sets up start/end nodes.
        /// </summary>
        /// <returns>True if runtime creation succeeded; otherwise, false.</returns>
        public bool CreateRuntime()
        {
            string graphName = !string.IsNullOrEmpty(m_GraphName) ? m_GraphName : "UnnamedGraph";
            if (!m_GraphJson || string.IsNullOrEmpty(m_GraphJson.text))
                m_RuntimeGraph ??= new InworldGraph(graphName);
            else
                ParseJson();
            if (!CreateNodesRuntime())
                return false;
            if (!CreateEdgesRuntime())
                return false;
            if (!SetupStartNodesRuntime())
                return false;
            if (!SetupEndNodesRuntime())
                return false;
            return true;
        }

        /// <summary>
        /// Sets up the starting node for runtime execution.
        /// Configures the graph's entry point for conversation flow.
        /// </summary>
        /// <returns>True if start node setup succeeded; otherwise, false.</returns>
        public bool SetupStartNodesRuntime()
        {
            if (m_ParsedRoot != null)
                return true;
            if (m_StartNode == null || m_StartNode.Runtime == null)
            {
                Debug.LogError($"[InworldFramework] Set StartNode Error.");
                return false;
            }
                
            m_RuntimeGraph.SetStartNode(m_StartNode.Runtime);
            Debug.Log($"[InworldFramework] Set StartNode: {m_StartNode.Runtime.ID}");
            return true;
        }
        
        /// <summary>
        /// Sets up the ending nodes for runtime execution.
        /// Configures the graph's exit points for conversation flow completion.
        /// </summary>
        /// <returns>True if end node setup succeeded; otherwise, false.</returns>
        public bool SetupEndNodesRuntime()
        {
            if (m_ParsedRoot != null)
                return true;
            if ((m_EndNode == null || m_EndNode.Runtime == null) && m_EndNodes.Count == 0)
            {
                Debug.LogError($"[InworldFramework] Set EndNode Error.");
                return false;
            }

            if (m_EndNode && m_EndNode.Runtime != null)
            {
                m_RuntimeGraph.SetEndNode(m_EndNode.Runtime);
                Debug.Log($"[InworldFramework] Set EndNode: {m_EndNode.Runtime.ID}");
            }
            else if (m_EndNodes.Count > 0)
            {
                foreach (InworldNodeAsset endNode in m_EndNodes)
                {
                    if (endNode.Runtime != null)
                    {
                        m_RuntimeGraph.SetEndNode(endNode.Runtime);
                        Debug.Log($"[InworldFramework] Set EndNode: {endNode.Runtime.ID}");
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Creates runtime representations for all edges in the graph.
        /// Initializes edge runtime objects for connection logic between nodes.
        /// </summary>
        /// <returns>True if edge runtime creation succeeded; otherwise, false.</returns>
        public bool CreateEdgesRuntime()
        {
            foreach (InworldEdgeAsset edgeAsset in m_Edges)
            {
                if (edgeAsset.IsValid)
                    continue;
                if (edgeAsset.RegisterJson(this))
                    continue;
                if (edgeAsset.CreateRuntime(this)) 
                    continue;
                Debug.LogError("[InworldFramework] Creating Runtime Edge failed");
                return false;
            }
            return true;
        }

        /// <summary>
        /// Creates runtime representations for all nodes in the graph.
        /// Initializes node runtime objects and adds them to the runtime graph.
        /// </summary>
        /// <returns>True if node runtime creation succeeded; otherwise, false.</returns>
        public bool CreateNodesRuntime()
        {
            foreach (InworldNodeAsset nodeAsset in m_Nodes)
            {
                if (nodeAsset.IsValid)
                    continue;
                if (nodeAsset.RegisterJson(this)) 
                    continue;
                if (m_RuntimeGraph == null)
                {
                    Debug.LogError($"[InworldFramework] Creating Runtime Node Failed. Runtime Graph is Null.");
                    continue; //return false;
                }
                if (!nodeAsset.CreateRuntime(this))
                {
                    Debug.LogError($"[InworldFramework] Creating Runtime for Node: {nodeAsset.NodeName} Type: {nodeAsset.NodeTypeName} failed");
                    return false;
                }
                if (nodeAsset.IsValid)
                {
                    m_RuntimeGraph.AddNode(nodeAsset.Runtime);
                    if (InworldFrameworkUtil.IsDebugMode)
                        Debug.Log($"[InworldFramework] Added runtime node: {nodeAsset.Runtime.ID}");
                }
                else
                {
                    Debug.LogError("[InworldFramework] Creating runtime node failed");
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compiles the runtime graph for optimized execution.
        /// Creates a compiled graph interface that provides efficient execution capabilities.
        /// </summary>
        /// <returns>True if graph compilation succeeded; otherwise, false.</returns>
        public bool CompileRuntime()
        {
            if (m_CompiledGraph == null || !m_CompiledGraph.IsValid)
            {
                if (m_ParsedRoot != null)
                {
                    InitializeRegistries();
                    ConfigParser parser = new ConfigParser();
                    if (!parser.IsValid)
                    {
                        Debug.LogError("[InworldFramework] Graph compiled Error: Unable to create parser.");
                        return false;
                    }
                    m_CompiledGraph = parser.ParseGraph(m_GraphJson.text, m_UserData?.ToHashMap); 
                }
                else
                {
                    if (m_RuntimeGraph == null)
                    {
                        Debug.LogError($"[InworldFramework] Graph compiled Error:Runtime graph is null.");
                        return false;
                    }
                    m_CompiledGraph = m_RuntimeGraph.CompileAndReturnRaw();
                }
            }
            if (m_CompiledGraph == null || !m_CompiledGraph.IsValid)
            {
                Debug.LogError($"[InworldFramework] Graph compiled Failed.");
                return false;
            }
            if (InworldFrameworkUtil.IsDebugMode)
                Debug.Log($"[InworldFramework] Graph compiled successfully with ID: {m_CompiledGraph.ID}");
            return true;
        }

        /// <summary>
        /// Creates the executor interface for running the compiled graph.
        /// Initializes the execution controller that manages graph flow and state.
        /// </summary>
        /// <returns>True if executor creation succeeded; otherwise, false.</returns>
        public bool CreateExecutorRuntime()
        {
            if (m_CompiledGraph == null)
            {
                Debug.LogError($"[InworldFramework] Cannot Create Execute Interface: Not Compiled.");
                return false;
            }
            m_Executor = m_CompiledGraph.CreateExecuteInterface();
            if (m_Executor == null || !m_Executor.IsValid)
            {
                Debug.LogError($"[InworldFramework] Cannot Create Execute Interface Failed.");
                return false;
            }
            if (InworldFrameworkUtil.IsDebugMode)
                Debug.Log($"[InworldFramework] Create Execute Interface Completed.");
            return true;
        }

        /// <summary>
        /// Starts the runtime execution of the graph.
        /// Begins the conversation flow using the configured executor.
        /// </summary>
        /// <returns>True if runtime startup succeeded; otherwise, false.</returns>
        public bool StartRuntime()
        {
            if (m_Executor == null)
            {
                Debug.LogError($"[InworldFramework] Cannot Start Runtime : No Executor.");
                return false;
            }
            m_Executor.Start();
            return true;
        }
        
        // Yan: This function needs to be optimized.
        //      It's currently used in the json referenced classes. Do not call it in the regular one.
        public virtual bool InitializeRegistries()
        {
            // TODO(Yan): Remove hardcode checking.
            if (!InworldComponentManager.IsRegistered("LLMInterface"))
            {
                IntPtr status = InworldInterop.inworld_InitializeRegistries();
                if (!InworldInterop.inworld_Status_ok(status))
                {
                    Debug.LogError(InworldInterop.inworld_Status_ToString(status));
                    return false;
                }
            }
            return true;
        }

        public virtual bool LoadGameData()
        {
            return true;
        }
        
        public void SaveJson(string outPath)
        {
            GraphConfigData config = new GraphConfigData
            {
                schemaVersion = "1.0.0",
                components = new List<ComponentData>(),
                main = new InworldGraphData
                {
                    id = string.IsNullOrEmpty(Name) ? "main_graph" : Name,
                    nodes = new List<ComponentData>(),
                    edges = new List<EdgeData>(),
                    startNodes = new List<string>(),
                    endNodes = new List<string>()
                }
            };

            // Serialize components from attached list
            if (m_Components != null)
            {
                foreach (InworldComponentAsset compAsset in m_Components.Where(compAsset => compAsset))
                {
                    config.components.Add(compAsset.ComponentData);
                }
            }
            
            // Serialize nodes (minimal: id/type)
            if (m_Nodes != null)
            {
                foreach (InworldNodeAsset nodeAsset in m_Nodes.Where(nodeAsset => nodeAsset))
                {
                    config.main.nodes.Add(nodeAsset.ComponentData);
                }
            }
            
            // Serialize edges
            foreach (InworldEdgeAsset edgeAsset in m_Edges)
            {
                if (!edgeAsset || edgeAsset.StartNode == null || edgeAsset.EndNode == null) 
                    continue;
                EdgeData edgeData = new EdgeData
                {
                    fromNode = edgeAsset.StartNode.NodeName,
                    toNode = edgeAsset.EndNode.NodeName
                };
                if (!edgeAsset.IsRequired)
                    // YAN: In Json mode. By default it's false. In API mode, by default it's true.
                    edgeData.optional = true; 
                if (edgeAsset.IsLoop)
                    edgeData.loop = true;
                if (!string.IsNullOrEmpty(edgeAsset.EdgeTypeName))
                    edgeData.conditionID = edgeAsset.ComponentID;
                config.main.edges.Add(edgeData);
            }

            // Start / End nodes
            if (m_StartNode)
                config.main.startNodes.Add(m_StartNode.NodeName);
            if (m_EndNode)
                config.main.endNodes.Add(m_EndNode.NodeName);
            if (m_EndNodes != null)
            {
                foreach (InworldNodeAsset end in m_EndNodes.Where(endNode => endNode))
                {
                    config.main.endNodes.Add(end.NodeName);
                }
            }

            // Write to file
            string json = JsonConvert.SerializeObject(config, Formatting.Indented);
            string directory = Path.GetDirectoryName(outPath);
            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
                Directory.CreateDirectory(directory);
            File.WriteAllText(outPath, json);
            Debug.Log($"[InworldFramework] Graph JSON exported: {outPath}");
            #if UNITY_EDITOR
            AssetDatabase.Refresh();
            m_GraphJson = AssetDatabase.LoadAssetAtPath<TextAsset>(outPath);
            EditorUtility.SetDirty(this);
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
            #endif
        }
    }
}